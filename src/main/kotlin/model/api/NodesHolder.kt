package model.api

import model.api.v1.dto.NodeRole
import java.net.InetSocketAddress

// 1. Если мы получили подтверждение входа, тогда мы подключаемся к ноде master.
// 1.1. Если мы имеем роль NORMAL или VIEWER, тогда нас не должны волновать другие ноды и достаточно хранить мастера.
// 1.2. Если мы имеем роль заместителя, в таком случае необходимо сохранять ноды других игроков во временном хранилище
//      ИЛИ создать функцию sendAll(gameState: GameState), которая будет извлекать адреса пользователей из сообщения
//      GameState, тем самым понимая, кому отправлять, а отсюда же будет получать информацию для актуализации нод.
// 2. Если мы приняли Join (для отслеживания этих действий используется специальный интерфейс), тогда нода также
//    добавляется.
//
// Резюмируя, получаем, что в простых случаях нода добавляется когда мы отправляем + получаем подтверждение на
// присоединение (MASTER NODE) и когда принимаем запрос на подключение.
// В сложных случаях (когда наша роль меняется на заместителя), необходимо извне получить информацию о нодах.
// Чтобы сохранить интерфейс чистым (только от join все зависит), предлагается внедрить получение инофрмации о нодах
// во время смены роли из кешированного состояния игры, а само состояние игры кешировать каждый раз, когда происходит
// его получение или отправление. Функция же sendAll также должна присутствовать, однако она лишь будет производить
// то, что от нее и ожидается - итерироваться по игрокам и отправлять им состояние игры.
//
// Если мы Deputy, Normal или Viewer, нужно отправлять сообщения мастеру. Если же мастер отвалился, нужно получить
// нового из кеша => необходимо кешировать Game. Так DEPUTY узнавая, что MASTER-нода отвалилась,
// сразу назначает себя на исполнителя и подгружает из кеша ноды, ожидая, что они теперь будут обращаться к нему, а
// Normal и View используют кеш, чтобы найти мастера.
class NodesHolder {
    private val connectedNodes: MutableMap<InetSocketAddress, NodeRole> = mutableMapOf()
    private val connectedNodesLock = Any()

    fun addNode(address: InetSocketAddress, role: NodeRole) {
        synchronized(connectedNodesLock) {
            if (!connectedNodes.contains(address)) {
                connectedNodes[address] = role
            }
        }
    }

    fun removeNode(address: InetSocketAddress) {
        // По-факту мы общаемся только с теми нодами, с которыми мы общаемся. Обычно других коммуникаций не наблюдается.
        // Мультикаст не стоит учитывать, а все юникасты сохраняем и если нода молчит -> удалена -> сообщения через лямбду об этом.
        // Сообщаем игровому состоянию, потому что именно оно будет ставить статусы зомби на змейку и управлять пользователями
        // в игре.
        synchronized(connectedNodesLock) {
            connectedNodes.remove(address)
        }
    }

    fun clearNodes() {
        synchronized(connectedNodesLock) {
            connectedNodes.clear()
        }
    }
}